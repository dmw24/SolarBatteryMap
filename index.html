<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Baseload Renewables - Global Energy System Performance Map</title>

    <!-- Leaflet.js for the map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

    <!-- D3.js for the Voronoi heatmap -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <!-- Chart.js + PapaParse + Tippy.js (Included for styling consistency, not fully integrated with map logic) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/scale.css"/>

    <style>
        /* Define CSS Variables */
        :root {
            --slate-blue: #192238;
            --off-white: #eceff5;
            --white: #fff;
            --grey-blue: #d6dbe9;
            --dark-grey: #959aa7;
            --color_theme_accent: #13ce74;
            --background_pop_darken: #11b767;
        }

        /* Global Styles */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        body {
            background: #f7f7f7; /* VERY LIGHT gray background */
            color: var(--slate-blue);
            font-family: 'Poppins', sans-serif; /* Using Poppins as per example */
            font-size: 15px;
            line-height: 23px;
            margin: 0;
        }

        /* HEADER */
        header.container {
            padding-bottom: 0.5rem;
            background: var(--white);
            border-bottom: 1px solid var(--grey-blue);
            margin-bottom: 1rem;
        }
        header.container h1 {
            margin: 20px 0;
            font-size: 3.2em;
            font-weight: 500;
            line-height: 1.2em;
            position: relative;
        }
        header.container h1::before {
            content: "";
            display: inline-block;
            width: 6px;
            height: 1em;
            background: var(--color_theme_accent);
            margin-right: 10px;
            vertical-align: middle;
        }
        header.container p.disclaimer {
            font-size: 0.9em;
            color: var(--dark-grey);
            margin: 0 0 1rem 0;
        }

        /* Container around everything */
        .container {
            width: 100%;
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            background: var(--white);
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }

        /* The main layout: sidebar + content */
        .sim-container {
            display: flex;
            gap: 20px;
            height: auto; /* Let content scroll if needed */
        }

        /* SIDEBAR */
        #sidebar {
            width: 320px;
            background: var(--white);
            padding: 1rem;
            padding-bottom: 30px;
            border: 1px solid var(--grey-blue);
            border-right: none;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            overflow-y: auto;
        }

        /* Content area */
        #content {
            flex-grow: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--grey-blue);
            border-radius: 8px;
        }

        /* Chart grid (adapted for map) */
        #chartSection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
        }

        /* Each chart box (adapted for map) */
        .chart-box {
            background: var(--white);
            border: 1px solid var(--grey-blue);
            border-radius: 8px;
            padding: 1rem;
        }
        .chart-box h3 {
            margin-top: 0;
        }
        /* Map specific height */
        #map {
            display: block;
            width: 100%;
            height: 500px; /* Adjusted height for better fit in the new layout */
        }

        /* Fieldset / form inputs */
        fieldset {
            margin-bottom: 20px;
            border: 1px solid var(--grey-blue); /* Added border to fieldset */
            padding: 15px; /* Added padding to fieldset */
            border-radius: 5px; /* Added border-radius to fieldset */
        }
        fieldset legend {
            border-left: 4px solid var(--color_theme_accent);
            padding-left: 8px;
            font-size: 1.1em;
            margin-bottom: 10px;
            font-weight: bold; /* Make legend bolder */
        }
        fieldset label {
            border-left: 2px solid var(--grey-blue);
            padding-left: 5px;
            margin-bottom: 5px;
            display: block;
            font-weight: 600;
        }
        input[type="number"],
        input[type="range"], /* Apply to range inputs too */
        select {
            width: 100%;
            padding: 0.4rem;
            border: 1px solid var(--grey-blue);
            border-radius: 4px;
            font-size: 0.95rem;
            background: var(--off-white); /* Slightly off-white background for inputs */
            color: var(--slate-blue);
            margin-bottom: 10px; /* Spacing below inputs */
        }

        /* Collapsible group toggles */
        #sidebar h2 {
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.8em;
            font-weight: 500;
            border-bottom: 1px solid var(--grey-blue);
            padding-bottom: 0.5rem;
        }
        .group-title {
            margin: 15px 0 10px 0;
            font-size: 1.5em;
            font-weight: 500;
            cursor: pointer;
            color: var(--slate-blue); /* Ensure title color is consistent */
        }
        .group-title::before {
            content: "";
            display: inline-block;
            width: 6px;
            height: 1.2em;
            background: var(--color_theme_accent);
            margin-right: 8px;
            vertical-align: middle;
        }
        .group-title::after {
            content: "►";
            float: right;
            font-size: 0.8em;
            vertical-align: middle;
            transition: transform 0.2s ease-in-out; /* Smooth arrow transition */
        }
        .group-title.expanded::after {
            content: "▼";
            transform: rotate(0deg); /* Reset rotation for expanded */
        }
        .group-title.collapsed::after {
            transform: rotate(90deg); /* Rotate for collapsed */
        }
        .group .group-content {
            display: none; /* Controlled by JS */
            margin-top: 10px;
            margin-bottom: 20px;
            padding-left: 0;
        }
        .group {
            margin-bottom: 20px;
            border: 1px solid var(--grey-blue); /* Border for the group itself */
            border-radius: 8px;
            padding: 1rem;
        }

        /* The "Run Model" button (removed from HTML, but keeping style for reference if needed) */
        /*
        #runModelBtn {
            width: 100%;
            padding: 10px;
            font-size: 1rem;
            border: none;
            border-radius: 4px;
            background-color: var(--color_theme_accent);
            color: var(--slate-blue);
            cursor: pointer;
            transition: background-color 0.2s;
            margin-bottom: 20px;
            font-weight: bold;
        }
        #runModelBtn:hover {
            background-color: var(--background_pop_darken);
        }
        */

        /* Responsive tweak for narrower screens */
        @media screen and (max-width: 767px) {
            .sim-container {
                flex-direction: column;
                height: auto;
            }
            #sidebar {
                width: 100%;
                border-right: 1px solid var(--grey-blue); /* Keep border on all sides for mobile */
                border-bottom: 1px solid var(--grey-blue);
            }
        }

        /* FOOTER */
        footer {
            position: relative; /* Changed to relative to avoid fixed positioning issues with content */
            width: 100%;
            background: var(--white);
            border-top: 1px solid var(--grey-blue);
            text-align: center;
            padding: 10px;
            font-size: 0.8em;
            color: var(--dark-grey);
            margin-top: 20px; /* Add some space above the footer */
        }
        footer strong {
            font-weight: bold;
        }

        /* Leaflet popup overrides for new theme */
        .leaflet-popup-content-wrapper {
            background-color: var(--slate-blue); /* Dark background */
            color: var(--off-white); /* Light text */
            border-radius: 0.5rem;
        }
        .leaflet-popup-tip {
            background: var(--slate-blue);
        }
        .leaflet-popup-content {
            margin: 12px 18px;
        }

        /* Legend Styles (adjusted for new theme) */
        .legend {
            padding: 10px 12px;
            font-family: 'Poppins', sans-serif;
            background: rgba(var(--slate-blue), 0.85); /* Use CSS var with opacity */
            color: var(--off-white);
            border-radius: 5px;
            line-height: 20px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            width: 200px;
        }
        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
        }
        /* Style for the Voronoi heatmap polygons */
        .voronoi-cell {
            stroke: rgba(255, 255, 255, 0.1); /* Lighter border for cells */
            stroke-width: 0.5;
        }
    </style>
</head>
<body>
    <!-- HEADER -->
    <header class="container">
        <h1>Baseload Renewables</h1>
        <p class="disclaimer">
            This tool visualizes global energy system performance, specifically focusing on "System Capacity Factor" and "Levelized Cost of Energy (LCOE)".
            Data is loaded automatically from CSV files in the same repository.
        </p>
    </header>

    <!-- MAIN LAYOUT WRAPPER -->
    <div class="container sim-container">
        <!-- SIDEBAR with input parameters -->
        <div id="sidebar">
            <h2>Model Parameters</h2>

            <!-- Status Message Display -->
            <div id="status-display" class="mb-4">
                <p id="status-message" class="text-sm text-gray-700">Loading energy data...</p>
            </div>

            <!-- Group: System Configuration & Visualization -->
            <div class="group" id="system-config-group">
                <h3 class="group-title" onclick="toggleGroup(this)">System Configuration & Visualization</h3>
                <div class="group-content">
                    <fieldset>
                        <legend>Select Mode</legend>
                        <div class="flex items-center space-x-4 mb-4">
                            <div>
                                <input type="radio" id="mode-mix" name="vis-mode" value="mix" checked class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                <label for="mode-mix" class="ml-2 inline">By System Mix</label>
                            </div>
                            <div>
                                <input type="radio" id="mode-lcoe" name="vis-mode" value="lcoe" class="h-4 w-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                <label for="mode-lcoe" class="ml-2 inline">By Max LCOE</label>
                            </div>
                        </div>
                    </fieldset>

                    <fieldset id="mix-sliders-section">
                        <legend>Capacity (By System Mix)</legend>
                        <div>
                            <label for="solar-slider" class="block mb-2 font-medium">Solar Capacity (GW): <span id="solar-value" class="font-bold">1 GW</span></label>
                            <input type="range" id="solar-slider" min="0" max="10" value="1" step="1" data-tippy-content="Select solar capacity in Gigawatts.">
                        </div>
                        <div>
                            <label for="wind-slider" class="block mb-2 font-medium">Wind Capacity (GW): <span id="wind-value" class="font-bold">0 GW</span></label>
                            <input type="range" id="wind-slider" min="0" max="4" value="0" step="1" data-tippy-content="Select wind capacity in Gigawatts.">
                        </div>
                        <div>
                            <label for="battery-slider" class="block mb-2 font-medium">Battery Capacity (GWh): <span id="battery-value" class="font-bold">0 GWh</span></label>
                            <input type="range" id="battery-slider" min="0" max="15" value="0" step="1" data-tippy-content="Select battery storage capacity in Gigawatt-hours.">
                        </div>
                    </fieldset>

                    <fieldset id="lcoe-slider-section" class="hidden">
                        <legend>Max LCOE</legend>
                        <div>
                            <label for="lcoe-slider" class="block mb-2 font-medium">Max LCOE ($/MWh): <span id="lcoe-value" class="font-bold">$100 / MWh</span></label>
                            <input type="range" id="lcoe-slider" min="20" max="200" value="100" step="1" data-tippy-content="Set the maximum Levelized Cost of Energy (LCOE) to filter locations.">
                        </div>
                    </fieldset>
                </div>
            </div>

            <!-- Group: Assumptions -->
            <div class="group">
                <h3 class="group-title" onclick="toggleGroup(this)">Assumptions</h3>
                <div class="group-content">
                    <fieldset>
                        <legend>Capital Costs</legend>
                        <label for="solarCapex">Solar Capex (USD/kW):</label>
                        <input type="number" id="solarCapex" value="600" step="1" />

                        <label for="windCapex">Wind Capex (USD/kW):</label>
                        <input type="number" id="windCapex" value="1300" step="1" />

                        <label for="batteryCapex">Battery Capex (USD/kWh):</label>
                        <input type="number" id="batteryCapex" value="120" step="1" />
                    </fieldset>

                    <fieldset>
                        <legend>Annual O&amp;M Costs</legend>
                        <label for="solarOpexPercent">Solar O&M (% of CAPEX):</label>
                        <input type="number" id="solarOpexPercent" value="1" step="0.1" />

                        <label for="windOpexPercent">Wind O&M (% of CAPEX):</label>
                        <input type="number" id="windOpexPercent" value="2.5" step="0.1" />

                        <label for="batteryOpexPercent">Battery O&M (% of CAPEX):</label>
                        <input type="number" id="batteryOpexPercent" value="2" step="0.1" />
                    </fieldset>

                    <fieldset>
                        <legend>Financial & Other</legend>
                        <label for="wacc">WACC (%):</label>
                        <input type="number" id="wacc" value="6" step="0.1" />

                        <label for="lifetimeSolar">Lifetime (solar) (years):</label>
                        <input type="number" id="lifetimeSolar" value="30" step="1" />
                        
                        <label for="lifetimeWind">Lifetime (wind) (years):</label>
                        <input type="number" id="lifetimeWind" value="25" step="1" />

                        <label for="lifetimeBattery">Lifetime (battery) (years):</label>
                        <input type="number" id="lifetimeBattery" value="20" step="1" />

                        <label>Demand (GW): 1.0 (fixed)</label>
                        <label>Hours per Year: 8760 (fixed)</label>
                    </fieldset>
                </div>
            </div>
        </div>

        <!-- CONTENT area with map -->
        <div id="content">
            <div id="chartSection">
                <!-- Map Container -->
                <div class="chart-box">
                    <h3>Global Performance Map</h3>
                    <div id="map"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- FOOTER -->
    <footer>
        Created by <strong>Daan Walter</strong>, 2025
    </footer>

    <script>
        // Chart.js defaults (kept for consistency, not directly used by map)
        Chart.defaults.font.family = 'Poppins', 'sans-serif';
        Chart.defaults.font.size = 15;

        // Toggle group content display on click
        function toggleGroup(el) {
            const content = el.nextElementSibling;
            if (content.style.display === "none" || content.style.display === "") {
                content.style.display = "block";
                el.classList.remove("collapsed");
                el.classList.add("expanded");
            } else {
                content.style.display = "none";
                el.classList.remove("expanded");
                el.classList.add("collapsed");
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            let map;
            let dispatchData = [];
            let circlesLayer = L.layerGroup();
            let voronoiLayer = L.svg();
            let legend;
            let worldGeoJSON;

            // Dynamically determine the base URL for the CSV files
            // This assumes the HTML file and CSVs are in the same directory on GitHub raw content.
            const GITHUB_RAW_BASE_URL = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
            const csvFiles = ['data_pt1.csv', 'data_pt2.csv', 'data_pt3.csv'];

            const statusMessage = document.getElementById('status-message');
            // This now refers to the main "System Configuration & Visualization" group
            const systemConfigGroup = document.getElementById('system-config-group'); 

            // Get references to sliders and labels
            const solarSlider = document.getElementById('solar-slider');
            const windSlider = document.getElementById('wind-slider');
            const batterySlider = document.getElementById('battery-slider');
            const lcoeSlider = document.getElementById('lcoe-slider');
            const solarValueLabel = document.getElementById('solar-value');
            const windValueLabel = document.getElementById('wind-value');
            const batteryValueLabel = document.getElementById('battery-value');
            const lcoeValueLabel = document.getElementById('lcoe-value');
            
            const modeMixRadio = document.getElementById('mode-mix');
            const modeLcoeRadio = document.getElementById('mode-lcoe');
            const mixSlidersSection = document.getElementById('mix-sliders-section'); // Fieldset for mix sliders
            const lcoeSliderSection = document.getElementById('lcoe-slider-section'); // Fieldset for LCOE slider

            // Removed runModelBtn as it's no longer needed
            // const runModelBtn = document.getElementById('runModelBtn');

            try {
                // Load world GeoJSON data for landmass clipping
                const geoJsonPromise = fetch('https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson')
                                      .then(response => response.json());
                
                // Load all CSV data files
                const csvPromises = csvFiles.map(file => 
                    fetch(`${GITHUB_RAW_BASE_URL}${file}`).then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to load ${file}: ${response.statusText}`);
                        }
                        return response.text();
                    })
                );

                statusMessage.textContent = "Fetching map and energy data...";
                const [geoJson, ...csvTexts] = await Promise.all([geoJsonPromise, ...csvPromises]);
                worldGeoJSON = geoJson;

                // Parse and append all CSV data
                csvTexts.forEach((text, index) => {
                    const parsed = parseCSV(text);
                    if (index === 0) { // For the first file, directly assign
                        dispatchData = parsed;
                    } else { // For subsequent files, append, skipping header if present
                        dispatchData = dispatchData.concat(parsed);
                    }
                });

                if (dispatchData.length > 0) {
                    statusMessage.textContent = `Successfully loaded ${dispatchData.length} total rows.`;
                    // Show the "System Configuration & Visualization" group
                    systemConfigGroup.classList.remove('hidden'); 
                } else {
                    statusMessage.textContent = 'Error: No data loaded from CSV files. Check file content.';
                    return;
                }

            } catch (e) {
                console.error("Error loading data:", e);
                statusMessage.textContent = `Error loading data: ${e.message}. Please ensure the CSV files are in the same directory as this HTML file on GitHub.`;
                return;
            }

            // Initialize map after data is loaded
            map = L.map('map').setView([20, 0], 2);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);
            
            map.getPane('tilePane').style.zIndex = 200;
            voronoiLayer.addTo(map);
            circlesLayer.addTo(map);

            // Initial map update and legend addition after data is loaded
            updateMap();
            addLegend();

            // Initialize Tippy.js tooltips
            tippy('[data-tippy-content]', {
                animation: 'scale',
                theme: 'light-border'
            });

            // Collapse groups on load
            document.querySelectorAll('.group-title').forEach(el => {
                el.classList.add("collapsed");
                const content = el.nextElementSibling;
                content.style.display = "none";
            });
            // Ensure the main System Configuration group is expanded by default after load
            const initialSystemConfigTitle = systemConfigGroup.querySelector('.group-title');
            if (initialSystemConfigTitle) {
                toggleGroup(initialSystemConfigTitle);
            }


            function parseCSV(text) {
                const lines = text.trim().split('\n');
                if (lines.length < 2) return [];
                const header = lines[0].split(',').map(h => h.trim());
                const data = [];
                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',');
                    if (values.length !== header.length) continue;
                    const entry = {};
                    for (let j = 0; j < header.length; j++) {
                        const value = values[j].trim();
                        const numValue = parseFloat(value);
                        entry[header[j]] = isNaN(numValue) || value === '' ? value : numValue;
                    }
                    data.push(entry);
                }
                return data;
            }

            // --- Event Listeners for Mode Switching and Sliders ---
            modeMixRadio.addEventListener('change', () => {
                mixSlidersSection.classList.remove('hidden');
                lcoeSliderSection.classList.add('hidden');
                updateMap();
            });
            modeLcoeRadio.addEventListener('change', () => {
                mixSlidersSection.classList.add('hidden');
                lcoeSliderSection.classList.remove('hidden');
                updateMap();
            });

            // Sliders now trigger updateMap directly
            solarSlider.addEventListener('input', updateMap);
            windSlider.addEventListener('input', updateMap);
            batterySlider.addEventListener('input', updateMap);
            lcoeSlider.addEventListener('input', updateMap);
            map.on('moveend', updateMap);

            function updateMap() {
                if (dispatchData.length === 0 || !map || !worldGeoJSON) return;

                circlesLayer.clearLayers();
                d3.select(voronoiLayer._container).selectAll("*").remove();

                let dataToDisplay;
                const currentMode = document.querySelector('input[name="vis-mode"]:checked').value;

                if (currentMode === 'mix') {
                    solarValueLabel.textContent = `${solarSlider.value} GW`;
                    windValueLabel.textContent = `${windSlider.value} GW`;
                    batteryValueLabel.textContent = `${batterySlider.value} GWh`;
                    const selectedSolar = parseInt(solarSlider.value);
                    const selectedWind = parseInt(windSlider.value);
                    const selectedBattery = parseInt(batterySlider.value);

                    dataToDisplay = dispatchData.filter(row => 
                        row.Solar_GW === selectedSolar &&
                        row.Wind_GW === selectedWind &&
                        row.Battery_GWh === selectedBattery
                    );
                    statusMessage.textContent = `Displaying ${dataToDisplay.length} locations for the selected mix.`;
                } else { // LCOE mode
                    const maxLcoe = parseInt(lcoeSlider.value);
                    lcoeValueLabel.textContent = `$${maxLcoe} / MWh`;
                    
                    const allLocations = new Set(dispatchData.map(row => row.Location));
                    const bestConfigs = new Map();

                    // Initialize bestConfigs with placeholder for all locations
                    allLocations.forEach(location => {
                        bestConfigs.set(location, {
                            Location: location,
                            System_Capacity_Factor: 0, // Default to 0% CF
                            LCOE_USD_per_MWh: 'N/A',   // Default to N/A LCOE
                            Solar_GW: 'N/A',           // Default to N/A for mix
                            Wind_GW: 'N/A',
                            Battery_GWh: 'N/A'
                        });
                    });

                    // Iterate through data to find valid configurations
                    for (const row of dispatchData) {
                        if (typeof row.LCOE_USD_per_MWh === 'number' && row.LCOE_USD_per_MWh <= maxLcoe) {
                            const location = row.Location;
                            // Update only if it's a better CF or if the current entry is a placeholder (N/A LCOE)
                            const currentBest = bestConfigs.get(location);
                            if (currentBest.LCOE_USD_per_MWh === 'N/A' || row.System_Capacity_Factor > currentBest.System_Capacity_Factor) {
                                bestConfigs.set(location, row);
                            }
                        }
                    }
                    dataToDisplay = Array.from(bestConfigs.values());
                    statusMessage.textContent = `Displaying best CF for ${dataToDisplay.length} locations under $${maxLcoe}/MWh (including N/A).`;
                }

                
                const mapPoints = [];
                const associatedData = [];
                dataToDisplay.forEach(row => {
                    const { lat, lon } = parseLocation(row.Location);
                    if (lat !== null && lon !== null) {
                        const point = map.latLngToLayerPoint([lat, lon]);
                        mapPoints.push([point.x, point.y]);
                        associatedData.push(row);
                    }
                });
                
                const svg = d3.select(voronoiLayer._container);
                const transform = d3.geoTransform({point: function(x, y) {
                    const point = map.latLngToLayerPoint(new L.LatLng(y, x));
                    this.stream.point(point.x, point.y);
                }});
                const path = d3.geoPath().projection(transform);

                svg.append("defs").append("clipPath").attr("id", "clip-land").append("path").datum(worldGeoJSON).attr("d", path);

                if (mapPoints.length > 1) { // Ensure there's enough data for Delaunay/Voronoi
                    const delaunay = d3.Delaunay.from(mapPoints);
                    const mapSize = map.getSize();
                    const buffer = Math.max(mapSize.x, mapSize.y);
                    const voronoiBounds = [-buffer, -buffer, mapSize.x + buffer, mapSize.y + buffer];
                    const voronoi = delaunay.voronoi(voronoiBounds);
                    
                    svg.append("g").attr("clip-path", "url(#clip-land)").selectAll("path")
                       .data(mapPoints).enter().append("path")
                       .attr("d", (d, i) => voronoi.renderCell(i))
                       .style("fill", (d, i) => getColorForCF(associatedData[i].System_Capacity_Factor))
                       .style("fill-opacity", 0.6).attr("class", "voronoi-cell");
                } else if (mapPoints.length === 1) {
                    // Handle case with only one point to avoid Delaunay error
                    // Draw a single circle or small area for the point
                    svg.append("g").attr("clip-path", "url(#clip-land)").append("circle")
                       .attr("cx", mapPoints[0][0])
                       .attr("cy", mapPoints[0][1])
                       .attr("r", 10) // A small radius for visibility
                       .style("fill", getColorForCF(associatedData[0].System_Capacity_Factor))
                       .style("fill-opacity", 0.6)
                       .attr("class", "voronoi-cell");
                }


                dataToDisplay.forEach(row => {
                    const { lat, lon } = parseLocation(row.Location);
                    if (lat === null || lon === null) return;
                    const color = getColorForCF(row.System_Capacity_Factor);
                    const circle = L.circleMarker([lat, lon], { radius: 2, weight: 0, fillColor: color, fillOpacity: 0.9 }).addTo(circlesLayer);
                    
                    let tooltipContent;
                    if (currentMode === 'lcoe') {
                        // Handle N/A for LCOE and mix components
                        const displayLcoe = typeof row.LCOE_USD_per_MWh === 'number' ? `$${row.LCOE_USD_per_MWh.toFixed(2)}` : row.LCOE_USD_per_MWh;
                        const displaySolar = typeof row.Solar_GW === 'number' ? `${row.Solar_GW} GW` : row.Solar_GW;
                        const displayWind = typeof row.Wind_GW === 'number' ? `${row.Wind_GW} GW` : row.Wind_GW;
                        const displayBattery = typeof row.Battery_GWh === 'number' ? `${row.Battery_GWh} GWh` : row.Battery_GWh;

                        tooltipContent = `
                            <div style="font-family: sans-serif; text-align: left;">
                                <strong>Location:</strong> ${lat.toFixed(2)}, ${lon.toFixed(2)}<br>
                                <hr style="margin: 3px 0; border-color: #4b5563;">
                                <strong>Best CF:</strong> ${(row.System_Capacity_Factor * 100).toFixed(2)}%<br>
                                <strong>LCOE:</strong> ${displayLcoe}<br>
                                <hr style="margin: 3px 0; border-color: #4b5563;">
                                <strong>Optimal Mix:</strong><br>
                                &nbsp;&nbsp;Solar: ${displaySolar}<br>
                                &nbsp;&nbsp;Wind: ${displayWind}<br>
                                &nbsp;&nbsp;Battery: ${displayBattery}
                            </div>`;
                    } else {
                         tooltipContent = `
                            <div style="font-family: sans-serif;">
                                <strong>Location:</strong> ${lat.toFixed(2)}, ${lon.toFixed(2)}<br>
                                <strong>System CF:</strong> ${(row.System_Capacity_Factor * 100).toFixed(2)}%
                            </div>`;
                    }
                    circle.bindTooltip(tooltipContent);
                });
            }

            function parseLocation(locationString) {
                if (typeof locationString !== 'string') return { lat: null, lon: null };
                const parts = locationString.split('_');
                if (parts.length !== 2) return { lat: null, lon: null };
                try {
                    const lat = parseFloat(parts[0].replace('Lat', ''));
                    const lon = parseFloat(parts[1].replace('Lon', ''));
                    return { lat, lon };
                } catch (e) { return { lat: null, lon: null }; }
            }

            function getColorForCF(cf) {
                const colors = [
                    { p: 0.0,  color: { r: 0,   g: 0,   b: 255 } },   // Blue
                    { p: 0.3,  color: { r: 0,   g: 255, b: 0 } },   // Green
                    { p: 0.65, color: { r: 255, g: 165, b: 0 } },   // Orange
                    { p: 0.8,  color: { r: 255, g: 0,   b: 0 } },   // Bright Red
                    { p: 1.0,  color: { r: 139, g: 0,   b: 0 } }    // Darker Red
                ];
                if (cf <= 0) return `rgb(${colors[0].color.r}, ${colors[0].color.g}, ${colors[0].color.b})`;
                if (cf >= 1) return `rgb(${colors[4].color.r}, ${colors[4].color.g}, ${colors[4].color.b})`;
                let i = 1;
                while (colors[i].p < cf) { i++; }
                const lower = colors[i - 1];
                const upper = colors[i];
                const range = upper.p - lower.p;
                const scale = (cf - lower.p) / range;
                const r = Math.round(lower.color.r + scale * (upper.color.r - lower.color.r));
                const g = Math.round(lower.color.g + scale * (upper.color.g - lower.color.g));
                const b = Math.round(lower.color.b + scale * (upper.color.b - lower.color.b));
                return `rgb(${r},${g},${b})`;
            }

            function addLegend() {
                if (legend) map.removeControl(legend);
                legend = L.control({position: 'bottomright'});
                legend.onAdd = function (map) {
                    const div = L.DomUtil.create('div', 'info legend');
                    div.innerHTML = '<strong>System CF</strong>';
                    const gradient = L.DomUtil.create('div', '', div);
                    const gradientColors = [];
                    for (let i = 0; i <= 100; i++) {
                        gradientColors.push(getColorForCF(i / 100));
                    }
                    gradient.style.height = '20px';
                    gradient.style.marginTop = '5px';
                    gradient.style.marginBottom = '5px';
                    gradient.style.width = '100%';
                    gradient.style.background = `linear-gradient(to right, ${gradientColors.join(',')})`;
                    gradient.style.borderRadius = '3px';
                    const labels = L.DomUtil.create('div', 'legend-labels', div);
                    labels.innerHTML = '<span>0%</span><span>25%</span><span>50%</span><span>75%</span><span>100%</span>';
                    return div;
                };
                legend.addTo(map);
            }
        });
    </script>
</body>
</html>
